<!DOCTYPE html>
<html>
<head>
  <title>Responsive Space Shooter</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; }
    canvas { display: block; margin: auto; background: black; }

    /* On-screen buttons container */
    #buttons {
      position: fixed;
      bottom: 5%;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 20%; /* gap between left/right and fire button */
      z-index: 10;
    }

    .btn {
      background: green;
      color: black;
      font-weight: bold;
      font-size: 1.5em;
      text-align: center;
      line-height: 1;
      border-radius: 10px;
      user-select: none;
      touch-action: manipulation;
      width: 60px;
      height: 60px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }

    #shoot { background: red; }

    /* Restart button */
    #restart {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: green;
      color: black;
      font-weight: bold;
      font-size: 1.2em;
      width: 30%;
      max-width: 180px;
      height: 50px;
      line-height: 50px;
      text-align: center;
      border-radius: 10px;
      display: none;
      z-index: 20;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div id="buttons">
    <div id="left" class="btn">◀</div>
    <div id="right" class="btn">▶</div>
    <div id="shoot" class="btn">⚡</div>
  </div>

  <div id="restart">RESTART</div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let WIDTH = window.innerWidth;
    let HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    // Scale factor for responsive design
    let scaleFactor = Math.min(WIDTH/800, HEIGHT/600);
    if(WIDTH < 600) scaleFactor = 1.5; // increase size for small screens

    const playerImg = new Image();
    playerImg.src = 'player_ship.png'; // add to repo
    const enemyImg = new Image();
    enemyImg.src = 'enemy_ship.png';   // add to repo

    let player, playerBullets, enemies, enemyBullets;
    let enemyDirection, score, gameState;
    let enemyShootTimer = 0;

    const basePlayerSpeed = 6;
    const basePlayerBulletSpeed = 8;
    const baseEnemySpeed = 2;
    const baseEnemyBulletSpeed = 5;

    const leftBtn = document.getElementById('left');
    const rightBtn = document.getElementById('right');
    const shootBtn = document.getElementById('shoot');
    const restartBtn = document.getElementById('restart');

    let leftPressed=false, rightPressed=false, shootPressed=false;

    function resizeGame(){
      WIDTH = window.innerWidth;
      HEIGHT = window.innerHeight;
      canvas.width = WIDTH;
      canvas.height = HEIGHT;

      scaleFactor = Math.min(WIDTH/800, HEIGHT/600);
      if(WIDTH < 600) scaleFactor = 1.5;

      resetGame();
    }
    window.addEventListener('resize', resizeGame);

    function resetGame() {
      player = { x: WIDTH/2 - 25*scaleFactor, y: HEIGHT - 60*scaleFactor, w: 50*scaleFactor, h: 40*scaleFactor };
      playerBullets = [];
      enemyBullets = [];
      enemies = [];
      enemyDirection = 1;
      score = 0;
      gameState = 'playing';
      restartBtn.style.display = 'none';

      for(let row=0; row<2; row++){
        for(let col=0; col<8; col++){
          enemies.push({ x: (80 + col*80)*scaleFactor, y: (60 + row*60)*scaleFactor, w: 40*scaleFactor, h: 30*scaleFactor });
        }
      }
    }

    function drawPlayer() { ctx.drawImage(playerImg, player.x, player.y, player.w, player.h); }
    function drawEnemy(enemy) { ctx.drawImage(enemyImg, enemy.x, enemy.y, enemy.w, enemy.h); }
    function drawText(text, x, y, size=24, color='white') { ctx.fillStyle = color; ctx.font = `${size}px Arial`; ctx.fillText(text, x, y); }

    // Touch + Mouse events
    const setupButton = (btn, prop) => {
      btn.addEventListener('touchstart', e=>{ e.preventDefault(); window[prop]=true; });
      btn.addEventListener('touchend', e=>{ e.preventDefault(); window[prop]=false; });
      btn.addEventListener('touchcancel', ()=>window[prop]=false);
      btn.addEventListener('mousedown', ()=>window[prop]=true);
      btn.addEventListener('mouseup', ()=>window[prop]=false);
    }
    setupButton(leftBtn,'leftPressed');
    setupButton(rightBtn,'rightPressed');
    setupButton(shootBtn,'shootPressed');

    restartBtn.addEventListener('click', ()=>resetGame());

    document.addEventListener('keydown', e=>{
      if(e.key==='ArrowLeft') leftPressed=true;
      if(e.key==='ArrowRight') rightPressed=true;
      if(e.key===' ') shootPressed=true;
      if(e.key==='p') gameState=(gameState==='playing')?'paused':'playing';
      if(e.key==='r' && gameState==='dead') resetGame();
    });
    document.addEventListener('keyup', e=>{
      if(e.key==='ArrowLeft') leftPressed=false;
      if(e.key==='ArrowRight') rightPressed=false;
      if(e.key===' ') shootPressed=false;
    });

    function update(){
      const playerSpeed = basePlayerSpeed*scaleFactor;
      const playerBulletSpeed = basePlayerBulletSpeed*scaleFactor;
      const enemySpeed = baseEnemySpeed*scaleFactor;
      const enemyBulletSpeed = baseEnemyBulletSpeed*scaleFactor;

      if(gameState==='playing'){
        if(leftPressed && player.x>0) player.x -= playerSpeed;
        if(rightPressed && player.x+player.w<WIDTH) player.x += playerSpeed;
        if(shootPressed && playerBullets.length<5){
          playerBullets.push({ x: player.x+player.w/2-2*scaleFactor, y: player.y, w:5*scaleFactor, h:10*scaleFactor });
        }

        playerBullets.forEach((b,i)=>{ 
          b.y -= playerBulletSpeed; 
          if(b.y+b.h<0) playerBullets.splice(i,1); 
        });

        enemyBullets.forEach((b,i)=>{
          b.y += enemyBulletSpeed;
          if(b.y>HEIGHT) enemyBullets.splice(i,1);
          else if(b.x < player.x + player.w &&
                  b.x + b.w > player.x &&
                  b.y < player.y + player.h &&
                  b.y + b.h > player.y){
            gameState='dead';
            restartBtn.style.display='block';
          }
        });

        let moveDown=false;
        enemies.forEach(e=>{ e.x += enemySpeed*enemyDirection; if(e.x+e.w>=WIDTH || e.x<=0) moveDown=true; });
        if(moveDown){ enemyDirection*=-1; enemies.forEach(e=>e.y+=10*scaleFactor); }

        enemyShootTimer++;
        if(enemyShootTimer>50 && enemies.length>0){
          let shooter=enemies[Math.floor(Math.random()*enemies.length)];
          enemyBullets.push({ x: shooter.x+shooter.w/2-3*scaleFactor, y: shooter.y+shooter.h, w:6*scaleFactor, h:12*scaleFactor });
          enemyShootTimer=0;
        }

        enemies.forEach((e,ei)=>{
          playerBullets.forEach((b,bi)=>{
            if(b.x < e.x + e.w && b.x+b.w > e.x && b.y < e.y+e.h && b.y+b.h>e.y){
              enemies.splice(ei,1);
              playerBullets.splice(bi,1);
              score++;
            }
          });
        });
      }

      ctx.clearRect(0,0,WIDTH,HEIGHT);
      drawPlayer();
      enemies.forEach(drawEnemy);
      playerBullets.forEach(b=>{ ctx.fillStyle='white'; ctx.fillRect(b.x,b.y,b.w,b.h); });
      enemyBullets.forEach(b=>{ ctx.fillStyle='yellow'; ctx.fillRect(b.x,b.y,b.w,b.h); });
      drawText(`Score: ${score}`, 10, 30, 24*scaleFactor, 'white');

      if(gameState==='paused') drawText('PAUSED', WIDTH/2-60*scaleFactor, HEIGHT/2, 48*scaleFactor, 'yellow');
      if(gameState==='dead') drawText('YOU DIED', WIDTH/2-80*scaleFactor, HEIGHT/2-20*scaleFactor, 48*scaleFactor, 'red');

      requestAnimationFrame(update);
    }

    resetGame();
    update();
  </script>
</body>
</html>
